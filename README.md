# ROS 2 Types Registry

A Zenoh application exploring all the ROS types available in a ROS 2 environment and exposing informations on those types as a Zenoh Queryable.

## How to build it

Install Rust if not already done.
Then run:
  `cargo build --release`

## Usage

The ROS 2 environment must be setup, especially the `AMENT_PREFIX_PATH` environment variable must be set to the list of paths where the ROS 2 packages are installed.

```bash
$>  ./target/release/ros2-types-registry -h

Usage: ros2-types-registry [OPTIONS]

Options:
  -c, --config <CONFIG>          A configuration file
      --cfg <CFG>                Allows arbitrary configuration changes as column-separated KEY:VALUE pairs, where: - KEY must be a valid config path. - VALUE must be a valid JSON5 string that can be deserialized to the expected type for the KEY field
  -m, --mode <MODE>              The Zenoh session mode [default: client]
  -e, --connect <CONNECT>        Endpoints to connect to
  -l, --listen <LISTEN>          Endpoints to listen on. [default: tcp/localhost:7447]
      --no-multicast-scouting    Disable the multicast-based scouting mechanism
      --rest-http-port <SOCKET>  Configures HTTP interface for the REST API (disabled by default). Accepted values: - a port number - a string with format `<local_ip>:<port_number>` (to bind the HTTP server to a specific interface) - `none` to disable the REST API
  -h, --help                     Print help (see more with '--help')
```

## How does it work ?

At startup the application searches for all `.msg`, `.srv` and `.action` files in the list of directories defined by the `AMENT_PREFIX_PATH` environment variable. It reads each file, as well as the associated `.json` file generated by `ros2idl`.

The types information details can then be queried by any Zenoh application using a Selector:  
**`@ros2_types/<type_name>`**  
where `<type_name>` is the full ROS type name - e.g.: `std_msgs/msg/String`

By default a reply contains the description of the type with JSON encoding.

The Selector accepts a `format` parameter with such values:

* `TypeDescription`: the type description in JSON
* `FullTypeDescription` : the full type description with dependencies in JSON
* `Definition` : the original .msg/.srv/.action definition
* `Mcap` : the type description for a MCAP schema
* `Hash` : the type hash string
* `Path` : the path to the original .msg/.srv/.action file

Additionally, the value of some environment variables defined for the host can be queried using such Selector:
**`@ros2_env/<environment_variable>`**
For instance, querying on `@ros2_env/ROS_DISTRO` returns the ROS distribution name (e.g. `kilted`).

## Examples of Selectors to query

* **`@ros2_types/sensor_msgs/msg/Temperature`**  
    <details>
    <summary>Response: the type description in JSON</summary>

    ```json
    {
    "fields": [
        {
        "default_value": "",
        "name": "header",
        "type": {
            "capacity": 0,
            "nested_type_name": "std_msgs/msg/Header",
            "string_capacity": 0,
            "type_id": "NestedType"
        }
        },
        {
        "default_value": "",
        "name": "temperature",
        "type": {
            "capacity": 0,
            "nested_type_name": "",
            "string_capacity": 0,
            "type_id": "Double"
        }
        },
        {
        "default_value": "",
        "name": "variance",
        "type": {
            "capacity": 0,
            "nested_type_name": "",
            "string_capacity": 0,
            "type_id": "Double"
        }
        }
    ],
    "type_name": "sensor_msgs/msg/Temperature"
    }
    ```
   </details>

* **`@ros2_types/sensor_msgs/msg/Temperature?format=FullTypeDescription`**  
    <details>
    <summary>Response: the full type description with dependencies in JSON</summary>

    ```json
    {
    "referenced_type_descriptions": [
        {
        "fields": [
            {
            "default_value": "",
            "name": "sec",
            "type": {
                "capacity": 0,
                "nested_type_name": "",
                "string_capacity": 0,
                "type_id": "Int32"
            }
            },
            {
            "default_value": "",
            "name": "nanosec",
            "type": {
                "capacity": 0,
                "nested_type_name": "",
                "string_capacity": 0,
                "type_id": "UInt32"
            }
            }
        ],
        "type_name": "builtin_interfaces/msg/Time"
        },
        {
        "fields": [
            {
            "default_value": "",
            "name": "stamp",
            "type": {
                "capacity": 0,
                "nested_type_name": "builtin_interfaces/msg/Time",
                "string_capacity": 0,
                "type_id": "NestedType"
            }
            },
            {
            "default_value": "",
            "name": "frame_id",
            "type": {
                "capacity": 0,
                "nested_type_name": "",
                "string_capacity": 0,
                "type_id": "String"
            }
            }
        ],
        "type_name": "std_msgs/msg/Header"
        }
    ],
    "type_description": {
        "fields": [
        {
            "default_value": "",
            "name": "header",
            "type": {
            "capacity": 0,
            "nested_type_name": "std_msgs/msg/Header",
            "string_capacity": 0,
            "type_id": "NestedType"
            }
        },
        {
            "default_value": "",
            "name": "temperature",
            "type": {
            "capacity": 0,
            "nested_type_name": "",
            "string_capacity": 0,
            "type_id": "Double"
            }
        },
        {
            "default_value": "",
            "name": "variance",
            "type": {
            "capacity": 0,
            "nested_type_name": "",
            "string_capacity": 0,
            "type_id": "Double"
            }
        }
        ],
        "type_name": "sensor_msgs/msg/Temperature"
    }
    }
    ```
   </details>

* **`@ros2_types/sensor_msgs/msg/Temperature?format=Definition`**  
    <details>
    <summary>Response: the original Temperature.msg definition</summary>

    ```text
    # Single temperature reading.

    std_msgs/Header header # timestamp is the time the temperature was measured
                                # frame_id is the location of the temperature reading

    float64 temperature          # Measurement of the Temperature in Degrees Celsius.

    float64 variance             # 0 is interpreted as variance unknown.
    ```
    </details>

* **`@ros2_types/sensor_msgs/msg/Temperature?format=Mcap`**  
    <details>
    <summary>Response: the type description for a MCAP schema</summary>

    ```text
    # Single temperature reading.

    std_msgs/Header header # timestamp is the time the temperature was measured
                                # frame_id is the location of the temperature reading

    float64 temperature          # Measurement of the Temperature in Degrees Celsius.

    float64 variance             # 0 is interpreted as variance unknown.

    ================================================================================
    MSG: builtin_interfaces/Time
    # This message communicates ROS Time defined here:
    # https://design.ros2.org/articles/clock_and_time.html

    # The seconds component, valid over all int32 values.
    int32 sec

    # The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component.
    # e.g.
    # The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
    # The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
    uint32 nanosec

    ================================================================================
    MSG: std_msgs/Header
    # Standard metadata for higher-level stamped data types.
    # This is generally used to communicate timestamped data
    # in a particular coordinate frame.

    # Two-integer timestamp that is expressed as seconds and nanoseconds.
    builtin_interfaces/Time stamp

    # Transform frame with which this data is associated.
    string frame_id
    ````
    </details>

* **`@ros2_types/sensor_msgs/msg/Temperature?format=Hash`**  
    <details>
    <summary>Response: the type hash string</summary>

    ```text
    RIHS01_72514a14126ab9f8a9abec974c78e5610a367b59db5da355ff1fb982d5bad4b8
    ````
    </details>

* **`@ros2_types/sensor_msgs/msg/Temperature?format=Path`**  
    <details>
    <summary>Response: the path to the Temperature.msg file</summary>

    ```text
    /opt/ros/jazzy/share/sensor_msgs/msg/Temperature.msg
    ````
    </details>

* **`@ros2_types/sensor_msgs/msg/*?format=Hash`**  
    Responses: the type hash for each message types in `sensor_msgs`.

* **`@ros2_types/*/msg/*?format=Path`**  
    Responses: the path of all .msg files.

* **`@ros2_types/**?format=Path`**  
    Responses: the path of all .msg/.srv/.action files.

## Examples of URL to use with the REST plugin

The Zenoh REST plugin can be loaded by the Types Registry itself via the `--rest-http-port` option or can be loaded by any original Zenoh router (not `rmw_zenohd`).

For instance running:  
` ./target/release/ros2-types-registry --rest-http-port 8000`
you can query the Types Registry with such URLs:

* `http://your_robot.local:8000/@ros2_types/sensor_msgs/msg/Temperature`
* `http://your_robot.local:8000/@ros2_types/sensor_msgs/msg/Temperature?format=Mcap`
* `http://your_robot.local:8000/@ros2_types/*/msg/*?format=Path`
* `http://your_robot.local:8000/@ros2_types/**?format=Path`
